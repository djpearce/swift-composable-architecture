{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Dependencies in an application are the types and functions that need to interact with outside"},{"type":"text","text":" "},{"type":"text","text":"systems that you do not control. Classic examples of this are API clients that make network requests"},{"type":"text","text":" "},{"type":"text","text":"to servers, but also seemingly innocuous things such as "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" initializers, and even"},{"type":"text","text":" "},{"type":"text","text":"schedulers and clocks, can be thought of as dependencies."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"By controlling the dependencies our features need to do their job we gain the ability to completely"},{"type":"text","text":" "},{"type":"text","text":"alter the execution context a features runs in. This means in tests and Xcode previews you can"},{"type":"text","text":" "},{"type":"text","text":"provide a mock version of an API client that immediately returns some stubbed data rather than"},{"type":"text","text":" "},{"type":"text","text":"making a live network request to a server."}]},{"anchor":"The-need-for-controlled-dependencies","level":2,"type":"heading","text":"The need for controlled dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Suppose that you are building a todo application with a "},{"type":"codeVoice","code":"Todo"},{"type":"text","text":" model that has a UUID identifier:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todo: Equatable, Identifiable {","  let id: UUID","  var title = \"\"","  var isCompleted = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And suppose you have a reducer that handles an action for when the “Add todo” button is tapped,"},{"type":"text","text":" "},{"type":"text","text":"which appends a new todo to the end of the array:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  struct State {","    var todos: IdentifiedArrayOf<Todo> = []","    \/\/ ...","  }","  enum Action {","    case addButtonTapped","    \/\/ ...","  }","","  func reduce(into state: inout State, action: Action) -> Effect<Action, Never> {","    switch action {","    case .addButtonTapped:","      state.todos.append(Todo(id: UUID())","      return .none","","    \/\/ ...","    }","  }","}"]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"We are using "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" from our"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"},{"type":"text","text":" library because it provides a safe and"},{"type":"text","text":" "},{"type":"text","text":"ergonomic API for accessing elements from a stable ID rather than positional indices."}]}],"type":"aside","name":"Note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the reducer we are using the uncontrolled "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" initializer from Foundation. Every invocation"},{"type":"text","text":" "},{"type":"text","text":"of the initial produces a fully random UUID. That may seem like what we want, but unfortunately"},{"type":"text","text":" "},{"type":"text","text":"it wreaks havoc on our ability to test."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we tried writing a test for the add todo functionality we will quickly find that we can’t"},{"type":"text","text":" "},{"type":"text","text":"possibly predict what UUID will be produced for the new todo:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: ???)","    ]","  }","}"]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Read the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"},{"type":"text","text":" article to learn how to write tests for state mutations and effect"},{"type":"text","text":" "},{"type":"text","text":"execution in your features."}]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is no way to get this test to pass."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is why controlling dependencies is important. It allows us to substitute a UUID generator that"},{"type":"text","text":" "},{"type":"text","text":"is deterministic in tests, such as one that simply increments by 1 every time it is invoked."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with a controller UUID generator and can be accessed by using the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"get-url"},{"type":"text","text":" property wrapper to add a dependency to the"},{"type":"text","text":" "},{"type":"codeVoice","code":"Todos"},{"type":"text","text":" reducer:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.uuid) var uuid","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then when you need a new UUID you should reach for the dependency rather than reaching for the"},{"type":"text","text":" "},{"type":"text","text":"uncontrollable UUID initializer:"}]},{"type":"codeListing","syntax":"swift","code":["func reduce(into state: inout State, action: Action) -> Effect<Action, Never> {","  switch action {","  case .addButtonTapped:","    state.todos.append(Todo(id: self.uuid()) \/\/ ⬅️","    return .none","","  \/\/ ...","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you do this little bit of upfront work you instantly unlock the ability to test the feature by"},{"type":"text","text":" "},{"type":"text","text":"providing a controlled, deterministic version of the UUID generator in tests. The library even comes"},{"type":"text","text":" "},{"type":"text","text":"with such a version for the UUID generator, and it is called "},{"type":"codeVoice","code":"incrementing"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testAddTodo() async {","  let store = TestStore(","    initialState: Todos.State(), ","    reducer: Todos()","  )","","  store.dependencies.uuid = .incrementing","","  await store.send(.addButtonTapped) {","    $0.todos = [","      Todo(id: UUID(string: \"00000000-0000-0000-0000-000000000000\")!)","    ]","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This test will pass deterministically, 100% of the time, and this is why it is so important to"},{"type":"text","text":" "},{"type":"text","text":"control dependencies that interact with outside systems."}]},{"anchor":"Using-library-dependencies","level":2,"type":"heading","text":"Using library dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library comes with many common dependencies that can be used in a controllable manner. A full"},{"type":"text","text":" "},{"type":"text","text":"list can be seen in the documentation for "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"DependencyValues"}],"isActive":true,"type":"reference","identifier":"get-url","overridingTitle":"DependencyValues"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, suppose you have a feature that needs access to a date initializer, the main queue"},{"type":"text","text":" "},{"type":"text","text":"for time-based asynchrony, and a UUID initializer. All 3 dependencies can be added to your feature’s"},{"type":"text","text":" "},{"type":"text","text":"reducer:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  struct State {","    \/\/ ...","  }","  enum Action {","    \/\/ ...","  }","  @Dependency(\\.date) var date","  @Dependency(\\.mainQueue) var mainQueue","  @Dependency(\\.uuid) var uuid","","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Then, all 3 dependencies can easily be overridden with deterministic versions when testing the"},{"type":"text","text":" "},{"type":"text","text":"feature:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testTodos() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.date = .constant(Date(timeIntervalSinceReferenceDate: 0))","  store.dependencies.mainQueue = .immediate","  store.dependencies.uuid = .incrementing","","  \/\/ ...","}"]},{"anchor":"Registering-your-own-dependencies","level":2,"type":"heading","text":"Registering your own dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Although the library comes with many controllable dependencies out of the box, there are still"},{"type":"text","text":" "},{"type":"text","text":"times when you want to register your own dependencies with the library so that you can use the"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Dependency"},{"type":"text","text":" property wrapper. Doing this is quite similar to registering an environment value"},{"type":"text","text":" "},{"type":"text","text":"in SwiftUI (see "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First you create a type that conforms to the "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"TestDependencyKey"}],"isActive":true,"type":"reference","identifier":"get-url","overridingTitle":"TestDependencyKey"},{"type":"text","text":" "},{"type":"text","text":"protocol. The only requirement is that you provide a "},{"type":"codeVoice","code":"testValue"},{"type":"text","text":", which will be the version of the"},{"type":"text","text":" "},{"type":"text","text":"dependency used when your feature is run in a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["private enum APIClientKey: TestDependencyKey {","  static let testValue = APIClient.unimplemented","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We recommend having an “unimplemented” version of your dependency, that is, an implementation"},{"type":"text","text":" "},{"type":"text","text":"that triggers an "},{"type":"codeVoice","code":"XCTFail"},{"type":"text","text":" anytime one of its endpoints is invoked. This makes it so that you can"},{"type":"text","text":" "},{"type":"text","text":"stub the bare minimum of the dependency’s interface, allowing you to prove that your test flow"},{"type":"text","text":" "},{"type":"text","text":"doesn’t interact with any other endpoints."}]},{"style":"tip","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"To use a different, default version when your feature is run in an Xcode preview, use the"},{"type":"text","text":" "},{"type":"text","text":"optional "},{"type":"codeVoice","code":"previewValue"},{"type":"text","text":" requirement."}]},{"type":"codeListing","syntax":"swift","code":["extension APIClientKey {","  static let previewValue = APIClient.mock(.loggedIn)","}"]}],"type":"aside","name":"Tip"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next you extend the key to also conform to the "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"DependencyKey"}],"isActive":true,"type":"reference","identifier":"get-url","overridingTitle":"DependencyKey"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"which will be the version of the dependency used when your feature is run in an Xcode preview, in"},{"type":"text","text":" "},{"type":"text","text":"the simulator, or on a device:"}]},{"type":"codeListing","syntax":"swift","code":["extension APIClientKey: DependencyKey {","  static let liveValue = APIClient.live","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is the version of the dependency that can actually interact with outside systems. In this"},{"type":"text","text":" "},{"type":"text","text":"case it means the API client can actually make network requests to an external server."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, an extension must be made to "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"DependencyValues"}],"isActive":true,"type":"reference","identifier":"get-url","overridingTitle":"DependencyValues"},{"type":"text","text":" to expose a"},{"type":"text","text":" "},{"type":"text","text":"computed property for the dependency:"}]},{"type":"codeListing","syntax":"swift","code":["extension DependencyValues {","  var apiClient: APIClient {","    get { self[APIClientKey.self] }","    set { self[APIClientKey.self] = newValue }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With those few steps completed you can instantly access your API client dependency from any"},{"type":"text","text":" "},{"type":"text","text":"feature’s reducer by using the "},{"overridingTitleInlineContent":[{"type":"codeVoice","code":"@Dependency"}],"isActive":true,"type":"reference","identifier":"get-url","overridingTitle":"@Dependency"},{"type":"text","text":" property wrapper:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todos: ReducerProtocol {","  @Dependency(\\.apiClient) var apiClient","  \/\/ ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will automatically use the live dependency in previews, simulators and devices, and in"},{"type":"text","text":" "},{"type":"text","text":"tests you can override any endpoint of the dependency to return mock data:"}]},{"type":"codeListing","syntax":"swift","code":["@MainActor","func testFetchUser() async {","  let store = TestStore(","    initialState: Todos.State(),","    reducer: Todos()","  )","","  store.dependencies.apiClient.fetchUser = { _ in User(id: 1, name: \"Blob\") }","","  await store.send(.loadButtonTapped)","  await store.receive(.userResponse(.success(User(id: 1, name: \"Blob\")))) {","    $0.loadedUser = User(id: 1, name: \"Blob\")","  }","}"]},{"anchor":"Designing-dependencies","level":2,"type":"heading","text":"Designing dependencies"},{"anchor":"Overriding-dependencies","level":2,"type":"heading","text":"Overriding dependencies"},{"anchor":"Unimplemented-dependencies","level":2,"type":"heading","text":"Unimplemented dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"TODO: get urls"}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/composablearchitecture\/dependencies"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Dependencies","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn how to register dependencies with the library so that they can be immediately accessibly from"},{"type":"text","text":" "},{"type":"text","text":"any reducer."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Dependencies","role":"article","modules":[{"name":"ComposableArchitecture"}]},"hierarchy":{"paths":[["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing"],"generated":true}],"references":{"doc://ComposableArchitecture/documentation/ComposableArchitecture/TestStore":{"role":"symbol","title":"TestStore","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"TestStore"}],"abstract":[{"type":"text","text":"A testable runtime for a reducer."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/TestStore","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"TestStore"}],"url":"\/documentation\/composablearchitecture\/teststore"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/GettingStarted":{"role":"article","title":"Getting started","abstract":[{"type":"text","text":"Learn how to integrate the Composable Architecture into your project and write your first"},{"type":"text","text":" "},{"type":"text","text":"application."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/gettingstarted"},"doc://ComposableArchitecture/documentation/ComposableArchitecture":{"role":"collection","title":"ComposableArchitecture","abstract":[{"type":"text","text":"The Composable Architecture (TCA, for short) is a library for building applications in a consistent"},{"type":"text","text":" "},{"type":"text","text":"and understandable way, with composition, testing, and ergonomics in mind. It can be used in"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI, UIKit, and more, and on any Apple platform (iOS, macOS, tvOS, and watchOS)."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture","kind":"symbol","type":"topic","url":"\/documentation\/composablearchitecture"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Testing":{"role":"article","title":"Testing","abstract":[{"type":"text","text":"Learn how to write comprehensive and exhaustive tests for your features built in the Composable"},{"type":"text","text":" "},{"type":"text","text":"Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Testing","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/testing"},"https://github.com/pointfreeco/swift-identified-collections":{"title":"Identified Collections","titleInlineContent":[{"type":"text","text":"Identified Collections"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","url":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"},"get-url":{"title":"@Dependency","titleInlineContent":[{"type":"codeVoice","code":"@Dependency"}],"type":"link","identifier":"get-url","url":"get-url"},"doc://ComposableArchitecture/documentation/ComposableArchitecture/Performance":{"role":"article","title":"Performance","abstract":[{"type":"text","text":"Learn how to improve the performance of features built in the Composable Architecture."}],"identifier":"doc:\/\/ComposableArchitecture\/documentation\/ComposableArchitecture\/Performance","kind":"article","type":"topic","url":"\/documentation\/composablearchitecture\/performance"},"https://developer.apple.com/documentation/swiftui/environmentvalues":{"title":"docs","titleInlineContent":[{"type":"text","text":"docs"}],"type":"link","identifier":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues","url":"https:\/\/developer.apple.com\/documentation\/swiftui\/environmentvalues"}}}